<script>
(function() {

  var annotator = new Annotator();

  var Annotations = {};
  
  // preprocessing (often prototypical)
  Annotations.sugarMarkup = function(ctor, template) {
    var ptype = ctor.prototype;
    ptype.template = template;
    ptype._findInstanceNode = Annotations.findInstanceNode;
    ptype._updateBindings = ptype.updateBindings = Annotations.updateBindings;
    ptype._notes = annotator.annotate(template.content);
    return Annotations.desugarMarkup;
  };

  var doForBindings = function(context, obj, prop, cb) {
    var b$ = obj && obj[prop];
    b$ && b$.forEach(function(b) {
      cb(b, context._findInstanceNode(b.notes));
    });
  };

  // per-instance processing
  Annotations.desugarMarkup = function() {
    if (this._notes) {
      // construct listeners as described in preprocess annotations
      doForBindings(this, this._notes, 'events', function(e, node) {
        //this.listen(this.$$(e.slctr), e.name, this[e.handler]);
        this.listen(node, e.name, this[e.handler]);
      }.bind(this));
      // locate elements with ids described in preprocess annotations
      // TODO(sjmiles): perhaps it's better to do this lazily and memoize?
      // we would need to either create getters for $ entries or make the syntax
      // functional (this.$('foo') instead of this.$.foo)
      var $ = this.$ = {};
      doForBindings(this, this._notes, 'ids', function(e, node) {
        $[e.id] = node;
      }.bind(this));  
    }
  };

  // TODO(sjmiles): What's the best way to map notes to nodes?
  // It's possible `querySelector` is faster than 
  // `findInstanceNode`. `findInstanceNode` could also be optimized
  // to avoid recursion and/or to memoize a lookup structure.
  Annotations.findInstanceNode = function(note) {
    if (!this.root) {
      console.warn("Annotation::findInstanceNode invoked but `this.root` is falsey.")
    } else {
      return annotator.findInstanceNode(note, this.root);
    }
  };
  
  Annotations.updateBindings = function(name, value) {
    doForBindings(this, this._notes.textBindings, name, function(b, node) {
      node.innerHTML = value;
    }.bind(this));
    doForBindings(this, this._notes.propBindings, name, function(b, node) {
      node[b.lhs] = value;
    }.bind(this));
  };
    
  var mapAttributes = function(node, filter) {
    if (node.hasAttributes) {
      var map = [];
      for (var a$=node.attributes, i=a$.length-1, a, obj; i>=0; i--) {
        a = a$[i], obj = filter(a.name, a.value)
        if (obj) {
          map.push(obj);
        }
      }
      return map.length ? map : undefined;
    }
  };
  
  var annotators = [
    
    function(node, notes, root) {
      if (node.id) {
        var ids = root.ids || (root.ids = []);
        ids.push({id: node.id, notes: notes});
      }
    },

    function(node, notes, root) {
      if (node.nodeType === node.ELEMENT_NODE) {
        if (node.childElementCount === 0) {
          // look for textContent binding
          var v = (node.childElementCount == 0) && node.textContent;
          if (v.slice(0,2) === '{{') {
            var p = v.slice(2, -2);
            var tb$ = root.textBindings || (root.textBindings = {});
            var tb = tb$[p] || (tb$[p] = []);
            tb.push({
              notes: notes
            });
            node.textContent = '';
          }
        }
        // look for property bindings in attributes
        var pb$ = root.propBindings || (root.propBindings = {});
        mapAttributes(node, function(n, v) {
          if (v.slice(0,2) === '{{') {
            var p = v.slice(2, -2);
            var pb = pb$[p] || (pb$[p] = []);
            pb.push({
              lhs: n,
              notes: notes
            });
            node.removeAttribute(n);
            //node.setAttribute(n, '');
          }
        });
      }
    },                                
    
    function(node, notes, root) {
      if (node.nodeType === node.ELEMENT_NODE) {
        var events = mapAttributes(node, function(n, v) {
          if (n.slice(0, 3) === 'on-') {
            return {
              name: n.slice(3),
              handler: v,
              notes: notes
            };
          }
        });
        if (events) {
          root.events = root.events ? root.events.concat(events) : events;
        }
      }
    }
      
  ];
  
  annotators.forEach(annotator.addAnnotator.bind(annotator));

  Polymer.Annotations = Annotations;
  
})();
</script>