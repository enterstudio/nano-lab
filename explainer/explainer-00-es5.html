<!doctype html>
<html>
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

  <title>Explainer ES5</title>

  <style>

    body {
      font-family: sans-serif;
    }

  </style>

  <script src="../components/webcomponents-lite.min.js"></script>
  
</head>
<body>

  <x-foo-0></x-foo-0>
  <hr>  
  
  <script>
    'use strict';
    window.addEventListener('load', function() {
      var XFoo0 = function() {
        // The second argument to `registerElement` is object-with-prototype-property,
        // which duck-types as an ES6 class reference.
        // ES6 class references duck-type to ES5 constructor functions (also objects-with-prototype),
        // so we create a ES5 constructor function to contain our custom element logic.
        // However, CustomElements have special lifecycle and do not support custom constructors
        // so this function will never be called by the system (initialization is done in `createdCallback` 
        // instead).
        // In ES5 it's possible to hide the troublesome distinction between `constructor` and 
        // `createdCallback`, but it's not possible in ES6 (ES6 prevents calling constructors
        // from JS), so we just don't try.
        // Remember that this method is NOT USED by the system when constructing elements.
        // However, we can make it return an instance when invoked as `new XFoo0()` with
        // the code below. 
        // This line is optional and is never used unless your code does `new XFoo0()`.
        return document.createElement('x-foo-0');
      };
      XFoo0.prototype = {
        __proto__: HTMLElement.prototype,
        createdCallback: function() {
          this.innerHTML = this.localName + ' says I Live';
        }
      };
      document.registerElement('x-foo-0', XFoo0);
    });
  </script>

</body>
</html>
